{"version":3,"sources":["components/Kaodashi.tsx","components/Control.tsx","hooks/useWindowSize.tsx","components/Map.tsx","App.tsx","index.tsx"],"names":["Kaodashi","props","shotting","setShotting","imageLoaded","setImageLoaded","image","windowWidth","kaodashiRef","useRef","webcamRef","canvasRef","imageRef","headPosition","heads_position","canvasWidth","canvasHeight","height","width","cameraSize","head_width","cameraSizeResized","cameraPosition","top","left","prevShotting","value","ref","useEffect","current","usePrevious","video","ctx","getContext","fillStyle","fillRect","save","translate","scale","drawImage","restore","style","mirrored","audio","videoConstraints","position","src","process","key","alt","name","onLoad","Slide","in","direction","backgroundColor","display","flexDirection","justifyContent","alignItems","marginBottom","onClick","fontSize","StyledBox","styled","other","Box","flexFlow","right","borderRadius","Control","takeScreenShot","IconButton","color","useWindowSize","isWindowClient","window","useState","innerWidth","innerHeight","undefined","windowSize","setWindowSize","setSize","addEventListener","removeEventListener","Map","allImages","setImage","latitude","longitude","zoom","viewport","setViewport","Object","assign","onViewportChange","bottom","mapStyle","map","i","offsetLeft","offsetTop","App","pickedImage","URLSearchParams","document","location","search","substring","get","data","Math","floor","random","length","pickRandomImage","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.2bce8ba0.chunk.js","sourcesContent":["import React, { useRef, useEffect } from 'react';\n\nimport Webcam from 'react-webcam';\nimport CancelIcon from '@material-ui/icons/Cancel';\nimport Slide from '@material-ui/core/Slide';\n\nimport Image from '../types/Image';\n\nconst usePrevious = <T extends {}>(value: T): T | undefined => {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n};\n\ninterface Props {\n  shotting: boolean\n  setShotting: (shotting: boolean) => void\n  imageLoaded: boolean\n  setImageLoaded: (loaded: boolean) => void\n  image: Image\n  windowWidth: number\n}\n\nfunction Kaodashi(props: Props) {\n  const {\n    shotting,\n    setShotting,\n    imageLoaded,\n    setImageLoaded,\n    image,\n    windowWidth,\n  } = props;\n\n  const kaodashiRef = useRef<HTMLDivElement>(null);\n  const webcamRef = useRef<Webcam & HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const imageRef = useRef<HTMLImageElement>(null);\n\n  const headPosition = image.heads_position[0];\n  const canvasWidth = windowWidth;\n  const canvasHeight = image.height / image.width * canvasWidth;\n  const cameraSize = image.head_width * 2;\n  const cameraSizeResized = cameraSize / image.width * canvasWidth;\n  const cameraPosition = {\n    top: (headPosition[1] - cameraSize / 2) / image.width * canvasWidth,\n    left: (headPosition[0] - cameraSize / 2) / image.width * canvasWidth,\n  }\n\n  const prevShotting = usePrevious(shotting);\n  useEffect(() => {\n    if (!shotting || shotting === prevShotting) {\n      return;\n    }\n    if (\n      !kaodashiRef.current\n      || !webcamRef.current || !webcamRef.current.video\n      || !canvasRef.current || !imageRef.current\n    ) {\n      return;\n    }\n    const ctx = canvasRef.current.getContext('2d');\n    if (!ctx) {\n      return;\n    }\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n    ctx.save();\n    ctx.translate(canvasWidth, 0);\n    ctx.scale(-1, 1);\n    ctx.drawImage(webcamRef.current.video, canvasWidth - cameraPosition.left - cameraSizeResized, cameraPosition.top);\n    ctx.restore();\n    ctx.drawImage(imageRef.current, 0, 0, canvasWidth, canvasHeight);\n  }, [shotting, prevShotting, cameraPosition, canvasWidth, canvasHeight, cameraSizeResized]);\n\n  return (\n    <div ref={kaodashiRef} style={{ height: canvasHeight }}>\n      {imageLoaded && (\n        <Webcam\n          mirrored\n          audio={false}\n          videoConstraints={{ width: cameraSizeResized, height: cameraSizeResized }}\n          ref={webcamRef}\n          style={{ position: 'absolute', ...cameraPosition }}\n        />\n      )}\n      <img\n        src={`${process.env.PUBLIC_URL}/images/${image.key}.png`}\n        alt={image.name}\n        ref={imageRef}\n        style={{ position: 'absolute', width: '100%' }}\n        onLoad={() => setImageLoaded(true)}\n      />\n      <Slide in={shotting} direction='up'>\n        <div style={{\n          position: 'absolute',\n          width: '100%',\n          height: '100%',\n          backgroundColor: 'white',\n          display: shotting ? 'flex' : 'none',\n          flexDirection: 'column',\n          justifyContent: 'center',\n          alignItems: 'center',\n        }}>\n          <canvas\n            ref={canvasRef}\n            width={canvasWidth}\n            height={canvasHeight}\n            style={{\n              width: '95%',\n              marginBottom: 15,\n            }}\n          />\n          <CancelIcon onClick={() => setShotting(false)} fontSize='large' style={{ marginBottom: 100 }} />\n        </div>\n      </Slide>\n    </div>\n  )\n}\n\nexport default Kaodashi;","import React from 'react';\n\nimport IconButton from '@material-ui/core/IconButton';\nimport PhotoCamera from '@material-ui/icons/PhotoCamera';\nimport { styled } from '@material-ui/core/styles';\nimport Box, { BoxProps } from '@material-ui/core/Box';\n\ninterface StyledBoxProps {\n  windowWidth: number\n}\n\ninterface Props {\n  windowWidth: number\n  takeScreenShot: () => void\n}\n\nconst StyledBox = styled(({ windowWidth, ...other }: StyledBoxProps & Omit<BoxProps, keyof StyledBoxProps>) => <Box {...other} />)({\n  display: 'flex',\n  flexFlow: 'column',\n  position: 'absolute',\n  right: 5,\n  borderRadius: 25,\n  backgroundColor: 'rgba(255, 255, 255, 0.6)',\n  top: (props: StyledBoxProps) => props.windowWidth / 2 - 48,\n});\n\nfunction Control(props: Props) {\n  const {\n    windowWidth,\n    takeScreenShot,\n  } = props;\n  return (\n    <StyledBox windowWidth={windowWidth}>\n      <IconButton color='primary' onClick={takeScreenShot}>\n        <PhotoCamera />\n      </IconButton>\n    </StyledBox>\n  )\n}\n\nexport default Control;","import { useState, useEffect } from \"react\";\n\nfunction useWindowSize() {\n    const isWindowClient = typeof window === \"object\";\n\n    const [windowSize, setWindowSize] = useState(\n        isWindowClient ? { width: window.innerWidth, height: window.innerHeight } : undefined\n    );\n\n    //👇\n    useEffect(() => {\n        //a handler which will be called on change of the screen resize\n        function setSize() {\n            setWindowSize({ width: window.innerWidth, height: window.innerHeight });\n        }\n\n        if (isWindowClient) {\n            //register the window resize listener\n            window.addEventListener(\"resize\", setSize);\n\n            //un-register the listener\n            return () => window.removeEventListener(\"resize\", setSize);\n        }\n    }, [isWindowClient, setWindowSize]);\n    //☝️\n\n    return windowSize;\n}\n\nexport default useWindowSize;","import React, { useState } from 'react';\n\nimport RoomIcon from '@material-ui/icons/Room';\nimport ReactMapGL, { Marker } from 'react-map-gl';\n\nimport useWindowSize from '../hooks/useWindowSize';\nimport Image from '../types/Image';\n\ninterface Props {\n  image: Image,\n  allImages: Image[],\n  setImage: (image: Image) => void,\n  shotting: boolean,\n}\n\nfunction Map(props: Props) {\n  const { image, allImages, setImage, shotting } = props;\n  const { latitude, longitude, key } = image;\n  const windowSize = useWindowSize();\n  const [viewport, setViewport] = useState({\n    latitude,\n    longitude,\n    width: 400,\n    height: 400,\n    zoom: 7,\n  });\n  return (\n    <ReactMapGL\n      {...Object.assign(viewport, {\n        width: windowSize ? windowSize.width : 0,\n        height: windowSize ? (windowSize.height - windowSize.width + 50) : 0,\n      })}\n      onViewportChange={setViewport}\n      style={{ display: shotting ? 'none' : 'inherit', position: 'absolute', bottom: 0, width: '100%' }}\n      mapStyle='mapbox://styles/mapbox/streets-v11'\n    >\n      {\n        allImages.map(i => (\n          <Marker\n            latitude={i.latitude}\n            longitude={i.longitude}\n            key={i.key}\n            offsetLeft={-20}\n            offsetTop={-10}\n          >\n            {i.key === key ? <RoomIcon color='secondary' /> : <RoomIcon color='primary' onClick={() => setImage(i)} />}\n          </Marker>\n        ))\n      }\n    </ReactMapGL>\n  )\n}\n\nexport default Map;","import React, { useState, useEffect } from 'react';\n\nimport Kaodashi from './components/Kaodashi';\nimport Control from './components/Control';\nimport Map from './components/Map';\nimport useWindowSize from './hooks/useWindowSize';\nimport Image from './types/Image';\nimport data from './data.json';\n\nfunction pickRandomImage(data: Image[]) {\n  return data[Math.floor(Math.random() * Math.floor(data.length))];\n}\n\nfunction App() {\n  const [shotting, setShotting] = useState(false);\n  const [imageLoaded, setImageLoaded] = useState(false);\n  const [image, setImage] = useState<Image | null>(null);\n\n  const windowSize = useWindowSize();\n\n  useEffect(() => {\n    const params = new URLSearchParams(document.location.search.substring(1));\n    const key = params.get('key');\n    let pickedImage;\n    if (key) {\n      for (const image of data) {\n        if (image.key === key) {\n          pickedImage = image;\n          break;\n        }\n      }\n    }\n    if (!pickedImage) {\n      pickedImage = pickRandomImage(data);\n    }\n    setImage(pickedImage);\n  }, [])\n\n  if (!image || !windowSize) {\n    return <div>Loading</div>;\n  }\n\n  return (\n    <div style={{ width: '100%' }}>\n      <Map\n        image={image}\n        allImages={data}\n        setImage={(image: Image) => { setImageLoaded(false); setImage(image) }}\n        shotting={shotting}\n      />\n      <Kaodashi\n        shotting={shotting}\n        setShotting={setShotting}\n        image={image}\n        imageLoaded={imageLoaded}\n        setImageLoaded={setImageLoaded}\n        windowWidth={windowSize.width}\n      />\n      {!shotting && imageLoaded && (\n        <Control\n          windowWidth={windowSize.width}\n          takeScreenShot={() => setShotting(true)}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n"],"sourceRoot":""}